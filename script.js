const translations = {
    es: {
        title: "Alimentación Renal Inteligente",
        subtitle: "Tu compañera digital para el control nutricional avanzado",
        description: "Bienvenido a la herramienta definitiva para pacientes renales. Consulta al instante los valores críticos de tus alimentos (Potasio, Fósforo, Proteínas) y toma decisiones informadas para cuidar tu salud renal con precisión milimétrica.",
        searchPlaceholder: "¿Qué vas a comer hoy? (Ej: Manzana, Pollo...)",
        amountLabel: "Cantidad (gramos)",
        nutritionalInfo: "Información Nutricional",
        protein: "Proteínas",
        sugar: "Azúcares",
        fat: "Grasas",
        potassium: "Potasio",
        phosphorus: "Fósforo",
        salt: "Sal",
        calcium: "Calcio",
        feedbackTitle: "Enviar sugerencias",
        feedbackDesc: "Ayúdanos a mejorar. ¿Qué funcionalidad te gustaría ver?",
        feedbackPlaceholder: "Escribe tu sugerencia aquí...",
        cancel: "Cancelar",
        send: "Enviar",
        acceptTerms: "He leído y acepto los",
        termsLink: "Términos y Condiciones",
        termsTitle: "Términos y Condiciones",
        closeBtn: "Cerrar",
        validationTerms: "Debes aceptar los términos y condiciones.",
        termsContent: `
            <h3>1. Uso Informativo</h3>
            <p>Esta aplicación es una herramienta de soporte nutricional y educativo. <strong>No sustituye el consejo, diagnóstico o tratamiento médico profesional.</strong></p>
            <h3>2. Responsabilidad</h3>
            <p>Los datos nutricionales son estimaciones. El usuario es responsable de verificar la idoneidad de los alimentos con su nefrólogo o dietista.</p>
            <h3>3. Privacidad</h3>
            <p>Sus datos de salud se almacenan localmente y en una base de datos segura. No se comparten con terceros sin su consentimiento explícito.</p>
        `,
        validationGeneric: "Por favor, completa todos los campos marcados",
        // Auth
        userBtn: "Usuario",
        loginBtn: "Entrar",
        registerBtn: "Registrarse",
        createAccount: "Crear Cuenta",
        welcomeBack: "Bienvenido de nuevo",
        name: "Nombre",
        surnames: "Apellidos",
        birthdate: "Fecha de Nacimiento",
        email: "Email",
        password: "Contraseña",
        rememberMe: "Recuérdame",
        forgotPassword: "¿Olvidaste tu contraseña?",
        noAccount: "¿No tienes cuenta?",
        registerLink: "Registrarse",
        loginLink: "Entrar",
        // Forgot Password
        forgotPasswordTitle: "Recuperar Contraseña",
        forgotPasswordDesc: "Ingresa tu email y te enviaremos un enlace para restablecerla.",
        sendLink: "Enviar enlace",
        backToLogin: "Volver",
        resetPasswordTitle: "Nueva Contraseña",
        resetPasswordDesc: "Introduce tu nueva contraseña.",
        newPassword: "Nueva Contraseña",
        changePassword: "Cambiar Contraseña",
        linkSent: "Revisa tu correo. Si existe, hemos enviado un enlace.",
        passwordChanged: "Contraseña actualizada exitosamente.",
        // Placeholders
        placeholderName: "Tu nombre",
        placeholderSurnames: "Tus apellidos",
        placeholderEmail: "ejemplo@email.com",
        placeholderPassword: "••••••••",
        // Validation
        validationEmpty: "Completa este campo",
        validationEmail: "Introduce un email válido",
        validationDate: "Introduce una fecha válida",
        // Medical Profile
        medicalProfileTitle: "Perfil Médico",
        medicalProfileDesc: "Complete su perfil para personalizar su experiencia.",
        questionInsufficiency: "¿Tiene insuficiencia renal?",
        yes: "Sí",
        no: "No",
        questionTreatment: "Tratamiento",
        selectOption: "Seleccione una opción",
        dialysis: "Diálisis",
        transplant: "Trasplante",
        erca: "ERCA",
        questionStage: "Estadio de la enfermedad renal",
        saveBtn: "Guardar",
        // New Profile
        profile: "Perfil",
        logout: "Cerrar Sesión",
        personalData: "Datos Personales",
        medicalData: "Datos Médicos",
        cancel: "Cancelar",
        stage1: "Estadio 1",
        stage2: "Estadio 2",
        stage3a: "Estadio 3A",
        stage3b: "Estadio 3B",
        stage4: "Estadio 4",
        stage5: "Estadio 5",
        // Categories
        catAll: "Todos",
        catDairy: "Leche y derivados (lácteos)",
        catProteins: "Carnes, pescados y huevos",
        catLegumesNutsGroup: "Legumbres y frutos secos",
        catVeg: "Verduras y hortalizas",
        catFruits: "Frutas",
        catCarbs: "Cereales, pasta, pan y derivados",
        catFats: "Grasas, aceites y mantequillas",
        catSweets: "Azúcares y dulces",
        catLegumesSpec: "Legumbres (específico)",
        catNutsSpec: "Frutos secos (específico)",
        catTubersSpec: "Tubérculos (específico)",
        catDrinks: "Bebidas (agua/infusiones)"
    },
    en: {
        title: "Smart Renal Diet",
        subtitle: "Your digital companion for advanced nutritional control",
        description: "Welcome to the ultimate tool for kidney patients. Instantly check critical food values (Potassium, Phosphorus, Protein) and make informed decisions to care for your renal health with millimetric precision.",
        searchPlaceholder: "What are you eating today? (e.g., Apple, Chicken...)",
        amountLabel: "Amount (grams)",
        nutritionalInfo: "Nutritional Information",
        protein: "Protein",
        sugar: "Sugars",
        fat: "Fat",
        potassium: "Potassium",
        phosphorus: "Phosphorus",
        salt: "Salt",
        calcium: "Calcium",
        feedbackTitle: "Send Feedback",
        feedbackDesc: "Help us improve. What features would you like to see?",
        feedbackPlaceholder: "Write your suggestion here...",
        cancel: "Cancel",
        send: "Send",
        acceptTerms: "I have read and accept the",
        termsLink: "Terms and Conditions",
        termsTitle: "Terms and Conditions",
        closeBtn: "Close",
        validationTerms: "You must accept the terms and conditions.",
        termsContent: `
            <h3>1. Informational Use</h3>
            <p>This application is a nutritional and educational support tool. <strong>It does not substitute professional medical advice, diagnosis, or treatment.</strong></p>
            <h3>2. Liability</h3>
            <p>Nutritional data are estimates. The user is responsible for verifying the suitability of foods with their nephrologist or dietitian.</p>
            <h3>3. Privacy</h3>
            <p>Your health data is stored locally and in a secure database. It is not shared with third parties without your explicit consent.</p>
        `,
        validationGeneric: "Please fill in all marked fields",
        // Auth
        userBtn: "User",
        loginBtn: "Login",
        registerBtn: "Sign Up",
        createAccount: "Create Account",
        welcomeBack: "Welcome Back",
        name: "Name",
        surnames: "Surnames",
        birthdate: "Date of Birth",
        email: "Email",
        password: "Password",
        rememberMe: "Remember me",
        forgotPassword: "Forgot password?",
        noAccount: "No account?",
        registerLink: "Sign Up",
        loginLink: "Login",
        // Forgot Password
        forgotPasswordTitle: "Recover Password",
        forgotPasswordDesc: "Enter your email and we'll send you a reset link.",
        sendLink: "Send Link",
        backToLogin: "Back to Login",
        resetPasswordTitle: "New Password",
        resetPasswordDesc: "Enter your new password.",
        newPassword: "New Password",
        changePassword: "Change Password",
        linkSent: "Check your email. If it exists, we sent a link.",
        passwordChanged: "Password updated successfully.",
        // Placeholders
        placeholderName: "Your name",
        placeholderSurnames: "Your surnames",
        placeholderEmail: "example@email.com",
        placeholderPassword: "••••••••",
        // Validation
        validationEmpty: "Please fill out this field",
        validationEmail: "Please enter a valid email",
        validationDate: "Please enter a valid date",
        // Medical Profile
        medicalProfileTitle: "Medical Profile",
        medicalProfileDesc: "Complete your profile to personalize your experience.",
        questionInsufficiency: "Do you have kidney failure?",
        yes: "Yes",
        no: "No",
        questionTreatment: "Treatment",
        selectOption: "Select an option",
        dialysis: "Dialysis",
        transplant: "Transplant",
        erca: "CKD (Advanced)",
        questionStage: "Kidney Disease Stage",
        questionStage: "Stage of kidney disease",
        saveBtn: "Save and Continue",
        profile: "Profile",
        logout: "Logout",
        personalData: "Personal Data",
        medicalData: "Medical Data",
        stage1: "Stage 1",
        stage2: "Stage 2",
        stage3a: "Stage 3A",
        stage3b: "Stage 3B",
        stage4: "Stage 4",
        stage5: "Stage 5",
        // New Profile
        catAll: "All",
        catDairy: "Dairy & Derivatives",
        catProteins: "Meat, Fish & Eggs",
        catLegumesNutsGroup: "Legumes & Nuts",
        catVeg: "Vegetables",
        catFruits: "Fruits",
        catCarbs: "Cereals & Pasta",
        catFats: "Fats & Oils",
        catSweets: "Sweets & Sugars",
        catLegumesSpec: "Legumes (Specific)",
        catNutsSpec: "Nuts (Specific)",
        catTubersSpec: "Tubers (Specific)",
        catDrinks: "Drinks"
    },
    de: {
        title: "Intelligente Nierendiät",
        subtitle: "Ihr digitaler Begleiter für fortgeschrittene Ernährungskontrolle",
        description: "Willkommen beim ultimativen Werkzeug für Nierenpatienten. Überprüfen Sie sofort kritische Lebensmittelwerte (Kalium, Phosphor, Protein) und treffen Sie fundierte Entscheidungen für Ihre Nierengesundheit.",
        searchPlaceholder: "Was essen Sie heute? (z.B. Apfel, Hühnchen...)",
        amountLabel: "Menge (Gramm)",
        nutritionalInfo: "Nährwertinformationen",
        protein: "Protein",
        sugar: "Zucker",
        fat: "Fett",
        potassium: "Kalium",
        phosphorus: "Phosphor",
        salt: "Salz",
        calcium: "Kalzium",
        feedbackTitle: "Feedback senden",
        feedbackDesc: "Helfen Sie uns, besser zu werden. Welche Funktionen wünschen Sie sich?",
        feedbackPlaceholder: "Schreiben Sie hier Ihren Vorschlag...",
        cancel: "Abbrechen",
        send: "Senden",
        acceptTerms: "Ich habe gelesen und akzeptiere die",
        termsLink: "Allgemeinen Geschäftsbedingungen",
        termsTitle: "Allgemeinen Geschäftsbedingungen",
        closeBtn: "Schließen",
        validationTerms: "Sie müssen die Allgemeinen Geschäftsbedingungen akzeptieren.",
        termsContent: `
            <h3>1. Informative Nutzung</h3>
            <p>Diese Anwendung ist ein Werkzeug zur Ernährungs- und Bildungsunterstützung. <strong>Sie ersetzt keine professionelle medizinische Beratung, Diagnose oder Behandlung.</strong></p>
            <h3>2. Haftung</h3>
            <p>Nährwertdaten sind Schätzungen. Der Benutzer ist dafür verantwortlich, die Eignung von Lebensmitteln mit seinem Nephrologen oder Ernährungsberater zu überprüfen.</p>
            <h3>3. Datenschutz</h3>
            <p>Ihre Gesundheitsdaten werden lokal und in einer sicheren Datenbank gespeichert. Sie werden ohne Ihre ausdrückliche Zustimmung nicht an Dritte weitergegeben.</p>
        `,
        validationGeneric: "Bitte füllen Sie alle markierten Felder aus",
        // Auth
        userBtn: "Benutzer",
        loginBtn: "Anmelden",
        registerBtn: "Registrieren",
        createAccount: "Konto erstellen",
        welcomeBack: "Willkommen zurück",
        name: "Name",
        surnames: "Nachname",
        birthdate: "Geburtsdatum",
        email: "E-Mail",
        password: "Passwort",
        rememberMe: "Erinnere dich an mich",
        forgotPassword: "Passwort vergessen?",
        noAccount: "Kein Konto?",
        registerLink: "Registrieren",
        loginLink: "Anmelden",
        // Placeholders
        placeholderName: "Dein Name",
        placeholderSurnames: "Dein Nachname",
        placeholderEmail: "beispiel@email.com",
        placeholderPassword: "••••••••",
        // Validation
        validationEmpty: "Bitte füllen Sie dieses Feld aus",
        validationEmail: "Bitte geben Sie eine gültige E-Mail ein",
        validationDate: "Bitte geben Sie ein gültiges Datum ein",
        // Medical Profile
        medicalProfileTitle: "Medizinisches Profil",
        medicalProfileDesc: "Vervollständigen Sie Ihr Profil für eine personalisierte Erfahrung.",
        questionInsufficiency: "Haben Sie Nierenversagen?",
        yes: "Ja",
        no: "Nein",
        questionTreatment: "Behandlung",
        selectOption: "Wählen Sie eine Option",
        dialysis: "Dialyse",
        transplant: "Transplantation",
        erca: "CKD (Fortgeschritten)",
        questionStage: "Stadium der Nierenerkrankung",
        saveBtn: "Speichern und Fortfahren",
        catAll: "Alle",
        catDairy: "Milchprodukte (Laktose)",
        catProteins: "Fleisch, Fisch und Eier",
        catLegumesNutsGroup: "Hülsenfrüchte und Nüsse",
        catVeg: "Gemüse",
        catFruits: "Obst",
        catCarbs: "Getreide, Nudeln und Brot",
        catFats: "Fette und Öle",
        catSweets: "Süßigkeiten und Zucker",
        catLegumesSpec: "Hülsenfrüchte (Spezifisch)",
        catNutsSpec: "Nüsse (Spezifisch)",
        catTubersSpec: "Knollen (Spezifisch)",
        catDrinks: "Getränke (Wasser/Tee)",
        profile: "Profil",
        logout: "Abmelden",
        personalData: "Persönliche Daten",
        medicalData: "Medizinische Daten",
        stage1: "Stadium 1",
        stage2: "Stadium 2",
        stage3a: "Stadium 3A",
        stage3b: "Stadium 3B",
        stage4: "Stadium 4",
        stage5: "Stadium 5"
    },
    fr: {
        title: "Alimentation Rénale Intelligente",
        subtitle: "Votre compagnon numérique pour un contrôle nutritionnel avancé",
        description: "Bienvenue sur l'outil ultime pour les patients rénaux. Consultez instantanément les valeurs critiques (Potassium, Phosphore, Protéines) et prenez des décisions éclairées pour votre santé rénale.",
        searchPlaceholder: "Que mangez-vous aujourd'hui ? (ex: Pomme, Poulet...)",
        amountLabel: "Quantité (grammes)",
        nutritionalInfo: "Information Nutritionnelle",
        protein: "Protéines",
        sugar: "Sucres",
        fat: "Graisses",
        potassium: "Potassium",
        phosphorus: "Phosphore",
        salt: "Sel",
        calcium: "Calcium",
        feedbackTitle: "Envoyer des commentaires",
        feedbackDesc: "Aidez-nous à nous améliorer. Quelles fonctionnalités aimeriez-vous voir ?",
        feedbackPlaceholder: "Écrivez votre suggestion ici...",
        cancel: "Annuler",
        send: "Envoyer",
        acceptTerms: "J'ai lu et j'accepte les",
        termsLink: "Termes et Conditions",
        termsTitle: "Termes et Conditions",
        closeBtn: "Fermer",
        validationTerms: "Vous devez accepter les termes et conditions.",
        termsContent: `
            <h3>1. Usage Informatif</h3>
            <p>Cette application est un outil de soutien nutritionnel et éducatif. <strong>Elle ne remplace pas les conseils, le diagnostic ou le traitement médical professionnel.</strong></p>
            <h3>2. Responsabilité</h3>
            <p>Les données nutritionnelles sont des estimations. L'utilisateur est responsable de vérifier l'adéquation des aliments avec son néphrologue ou diététicien.</p>
            <h3>3. Confidentialité</h3>
            <p>Vos données de santé sont stockées localement et dans une base de données sécurisée. Elles ne sont pas partagées avec des tiers sans votre consentement explicite.</p>
        `,
        validationGeneric: "Veuillez remplir tous les champs marqués",
        // Auth
        userBtn: "Utilisateur",
        loginBtn: "Connexion",
        registerBtn: "S'inscrire",
        createAccount: "Créer un compte",
        welcomeBack: "Bon retour",
        name: "Prénom",
        surnames: "Nom",
        birthdate: "Date de naissance",
        email: "Email",
        password: "Mot de passe",
        rememberMe: "Se souvenir de moi",
        forgotPassword: "Mot de passe oublié ?",
        noAccount: "Pas de compte ?",
        registerLink: "S'inscrire",
        loginLink: "Connexion",
        // Placeholders
        placeholderName: "Votre prénom",
        placeholderSurnames: "Votre nom",
        placeholderEmail: "exemple@email.com",
        placeholderPassword: "••••••••",
        // Validation
        validationEmpty: "Veuillez remplir ce champ",
        validationEmail: "Veuillez entrer un email valide",
        validationDate: "Veuillez entrer une date valide",
        // Medical Profile
        medicalProfileTitle: "Profil Médical",
        medicalProfileDesc: "Complétez votre profil pour une expérience personnalisée.",
        questionInsufficiency: "Avez-vous une insuffisance rénale ?",
        yes: "Oui",
        no: "Non",
        questionTreatment: "Traitement",
        selectOption: "Sélectionnez une option",
        dialysis: "Dialyse",
        transplant: "Greffe",
        erca: "MRC (Avancé)",
        questionStage: "Stade de la maladie rénale",
        saveBtn: "Enregistrer et Continuer",
        profile: "Profil",
        logout: "Se déconnecter",
        personalData: "Données personnelles",
        medicalData: "Données médicales",
        stage1: "Stade 1",
        stage2: "Stade 2",
        stage3a: "Stade 3A",
        stage3b: "Stade 3B",
        stage4: "Stade 4",
        stage5: "Stade 5",
        catAll: "Tout",
        catDairy: "Laitages et dérivés",
        catProteins: "Viandes, poissons et œufs",
        catLegumesNutsGroup: "Légumineuses et fruits à coque",
        catVeg: "Légumes et verdures",
        catFruits: "Fruits",
        catCarbs: "Céréales, pâtes et pain",
        catFats: "Graisses et huiles",
        catSweets: "Sucres et douceurs",
        catLegumesSpec: "Légumineuses (Spécifique)",
        catNutsSpec: "Fruits à coque (Spécifique)",
        catTubersSpec: "Tubercules (Spécifique)",
        catDrinks: "Boissons (eau/infusions)"
    },
    pt: {
        title: "Dieta Renal Inteligente",
        subtitle: "Seu companheiro digital para controle nutricional avançado",
        description: "Bem-vindo à ferramenta definitiva para pacientes renais. Verifique instantaneamente valores críticos (Potássio, Fósforo, Proteína) e tome decisões informadas para sua saúde renal.",
        searchPlaceholder: "O que você vai comer hoje? (ex: Maçã, Frango...)",
        amountLabel: "Quantidade (gramas)",
        nutritionalInfo: "Informação Nutricional",
        protein: "Proteínas",
        sugar: "Açúcares",
        fat: "Gorduras",
        potassium: "Potássio",
        phosphorus: "Fósforo",
        salt: "Sal",
        calcium: "Cálcio",
        feedbackTitle: "Enviar sugestões",
        feedbackDesc: "Ajude-nos a melhorar. Que funcionalidade gostaria de ver?",
        feedbackPlaceholder: "Escreva sua sugestão aqui...",
        cancel: "Cancelar",
        send: "Enviar",
        acceptTerms: "Li e aceito os",
        termsLink: "Termos e Condições",
        termsTitle: "Termos e Condições",
        closeBtn: "Fechar",
        validationTerms: "Você deve aceitar os termos e condições.",
        termsContent: `
            <h3>1. Uso Informativo</h3>
            <p>Esta aplicação é uma ferramenta de apoio nutricional e educativo. <strong>Não substitui o aconselhamento, diagnóstico ou tratamento médico profissional.</strong></p>
            <h3>2. Responsabilidade</h3>
            <p>Os dados nutricionais são estimativas. O utilizador é responsável por verificar a adequação dos alimentos com o seu nefrologista ou dietista.</p>
            <h3>3. Privacidade</h3>
            <p>Os seus dados de saúde são armazenados localmente e numa base de dados segura. Não são partilhados com terceiros sem o seu consentimento explícito.</p>
        `,
        validationGeneric: "Preencha todos os campos marcados",
        // Auth
        userBtn: "Usuário",
        loginBtn: "Entrar",
        registerBtn: "Registrar",
        createAccount: "Criar Conta",
        welcomeBack: "Bem-vindo de volta",
        name: "Nome",
        surnames: "Sobrenomes",
        birthdate: "Data de Nascimento",
        email: "Email",
        password: "Senha",
        rememberMe: "Lembrar de mim",
        forgotPassword: "Esqueceu a senha?",
        noAccount: "Não tem conta?",
        registerLink: "Registrar",
        loginLink: "Entrar",
        // Placeholders
        placeholderName: "Seu nome",
        placeholderSurnames: "Seus sobrenomes",
        placeholderEmail: "exemplo@email.com",
        placeholderPassword: "••••••••",
        // Validation
        validationEmpty: "Preencha este campo",
        validationEmail: "Insira um email válido",
        validationDate: "Insira uma data válida",
        // Medical Profile
        medicalProfileTitle: "Perfil Médico",
        medicalProfileDesc: "Complete seu perfil para personalizar sua experiência.",
        questionInsufficiency: "Você tem insuficiência renal?",
        yes: "Sim",
        no: "Não",
        questionTreatment: "Tratamento",
        selectOption: "Selecione uma opção",
        dialysis: "Diálise",
        transplant: "Transplante",
        erca: "DRC (Avançado)",
        questionStage: "Estágio da doença renal",
        saveBtn: "Salvar e Continuar",
        profile: "Perfil",
        logout: "Sair",
        personalData: "Dados Pessoais",
        medicalData: "Dados Médicos",
        stage1: "Estágio 1",
        stage2: "Estágio 2",
        stage3a: "Estágio 3A",
        stage3b: "Estágio 3B",
        stage4: "Estágio 4",
        stage5: "Estágio 5",
        catAll: "Todos",
        catDairy: "Leites e derivados (lácteos)",
        catProteins: "Carnes, peixes e ovos",
        catLegumesNutsGroup: "Leguminosas e frutos secos",
        catVeg: "Verduras e hortaliças",
        catFruits: "Frutas",
        catCarbs: "Cereais, massas, pão e derivados",
        catFats: "Gorduras, óleos e manteigas",
        catSweets: "Açúcares e doces",
        catLegumesSpec: "Leguminosas (específico)",
        catNutsSpec: "Frutos secos (específico)",
        catTubersSpec: "Tubérculos (específico)",
        catDrinks: "Bebidas (água/infusões)"
    },
    ja: {
        title: "スマート腎臓食",
        subtitle: "高度な栄養管理のためのデジタルパートナー",
        description: "腎臓病患者のための究極のツールへようこそ。食品の重要な値（カリウム、リン、タンパク質）を即座に確認し、腎臓の健康を正確に管理するための情報に基づいた決定を下します。",
        searchPlaceholder: "今日は何を食べますか？ (例: リンゴ, 鶏肉...)",
        amountLabel: "量 (グラム)",
        nutritionalInfo: "栄養情報",
        protein: "タンパク質",
        sugar: "糖質",
        fat: "脂質",
        potassium: "カリウム",
        phosphorus: "リン",
        salt: "塩分",
        calcium: "カルシウム",
        feedbackTitle: "フィードバックを送信",
        feedbackDesc: "改善にご協力ください。どのような機能をご希望ですか？",
        feedbackPlaceholder: "提案をここに書いてください...",
        cancel: "キャンセル",
        send: "送信",
        acceptTerms: "利用規約を読み、同意します",
        termsLink: "利用規約",
        termsTitle: "利用規約",
        closeBtn: "閉じる",
        validationTerms: "利用規約に同意する必要があります。",
        termsContent: `
            <h3>1. 情報としての利用</h3>
            <p>このアプリは栄養および教育支援ツールです。<strong>専門的な医学的アドバイス、診断、または治療に代わるものではありません。</strong></p>
            <h3>2. 免責事項</h3>
            <p>栄養データは推定値です。ユーザーは、食品の適合性を腎臓専門医または管理栄養士に確認する責任があります。</p>
            <h3>3. プライバシー</h3>
            <p>あなたの健康データはローカルおよび安全なデータベースに保存されます。明示的な同意なしに第三者と共有されることはありません。</p>
        `,
        validationGeneric: "マークされたすべてのフィールドに入力してください",
        // Auth
        userBtn: "ユーザー",
        loginBtn: "ログイン",
        registerBtn: "登録",
        createAccount: "アカウント作成",
        welcomeBack: "お帰りなさい",
        name: "名前",
        surnames: "姓",
        birthdate: "生年月日",
        email: "メール",
        password: "パスワード",
        rememberMe: "ログイン状態を保持",
        forgotPassword: "パスワードをお忘れですか？",
        noAccount: "アカウントをお持ちでないですか？",
        registerLink: "登録",
        loginLink: "ログイン",
        // Placeholders
        placeholderName: "お名前",
        placeholderSurnames: "姓",
        placeholderEmail: "example@email.com",
        placeholderPassword: "••••••••",
        // Validation
        validationEmpty: "このフィールドに入力してください",
        validationEmail: "有効なメールアドレスを入力してください",
        validationDate: "有効な日付を入力してください",
        cancel: "キャンセル",
        send: "送信",
        // Medical Profile
        medicalProfileTitle: "医療プロフィール",
        medicalProfileDesc: "体験をパーソナライズするためにプロフィールを完成させてください。",
        questionInsufficiency: "腎不全ですか？",
        yes: "はい",
        no: "いいえ",
        questionTreatment: "治療",
        selectOption: "オプションを選択",
        dialysis: "透析",
        transplant: "移植",
        erca: "保存期腎不全",
        questionStage: "腎臓病のステージ",
        saveBtn: "保存して続行",
        // New Profile
        catAll: "すべて",
        catDairy: "乳製品",
        catProteins: "肉・魚・卵",
        catLegumesNutsGroup: "豆類・ナッツ類",
        catVeg: "野菜類",
        catFruits: "果物類",
        catCarbs: "穀物・パスタ・パン",
        catFats: "油脂・バター類",
        catSweets: "砂糖・菓子類",
        catLegumesSpec: "豆類（詳細）",
        catNutsSpec: "ナッツ類（詳細）",
        catTubersSpec: "芋類（詳細）",
        catDrinks: "飲み物（水・お茶）",
        profile: "プロフィール",
        logout: "ログアウト",
        personalData: "個人データ",
        medicalData: "医療データ",
        stage1: "ステージ 1",
        stage2: "ステージ 2",
        stage3a: "ステージ 3A",
        stage3b: "ステージ 3B",
        stage4: "ステージ 4",
        stage5: "ステージ 5"
    }
};

// Global State
let currentFood = null;
let foodDatabase = [];
let currentLang = 'es';
let pendingAvatarUpload = null;

// DOM Elements
// DOM Elements
const gridContainer = document.getElementById('food-grid');
const modal = document.getElementById('food-modal');
const closeModalBtn = document.querySelector('.close-modal');
const gramsInput = document.getElementById('grams-input');
const searchInput = document.getElementById('search-input');
const categoryTabsContainer = document.getElementById('category-tabs');

// Categories Configuration
const categories = [
    { id: 'all', key: 'catAll', label: 'Todo' },
    { id: 'dairy', key: 'catDairy', label: 'Leche y derivados' },
    { id: 'proteins', key: 'catProteins', label: 'Carnes, pescados y huevos' },
    { id: 'legumes_nuts_group', key: 'catLegumesNutsGroup', label: 'Legumbres y frutos secos' },
    { id: 'vegetables', key: 'catVeg', label: 'Verduras y hortalizas' },
    { id: 'fruits', key: 'catFruits', label: 'Frutas' },
    { id: 'carbs', key: 'catCarbs', label: 'Cereales, pasta, pan' },
    { id: 'fats', key: 'catFats', label: 'Grasas y aceites' },
    { id: 'sweets', key: 'catSweets', label: 'Azúcares y dulces' },
    { id: 'legumes_spec', key: 'catLegumesSpec', label: 'Legumbres (específico)' },
    { id: 'nuts_spec', key: 'catNutsSpec', label: 'Frutos secos (específico)' },
    { id: 'tubers_spec', key: 'catTubersSpec', label: 'Tubérculos (específico)' },
    { id: 'drinks', key: 'catDrinks', label: 'Bebidas' }
];

let activeCategory = 'all';

// Feedback Elements
const feedbackBtn = document.getElementById('feedback-btn');
const feedbackModal = document.getElementById('feedback-modal');
const closeFeedbackBtn = document.getElementById('close-feedback');
const cancelFeedbackBtn = document.getElementById('cancel-feedback');
const sendFeedbackBtn = document.getElementById('send-feedback');
const feedbackText = document.getElementById('feedback-text');

// Auth View Switching Elements
const forgotPasswordBtn = document.getElementById('forgot-password-btn');
const authBody = document.querySelector('.auth-body:not(#forgot-password-view):not(#reset-password-view)'); // The main login/register body
const forgotView = document.getElementById('forgot-password-view');
const backToLoginBtn = document.getElementById('back-to-login');
const forgotForm = document.getElementById('forgot-form');
const forgotMsg = document.getElementById('forgot-msg');
const forgotError = document.getElementById('forgot-error');

// Reset Password Elements
const resetView = document.getElementById('reset-password-view');
const resetForm = document.getElementById('reset-form');
const resetMsg = document.getElementById('reset-msg');
const resetError = document.getElementById('reset-error');


// Modal Elements
const mImg = document.getElementById('modal-img');
const mName = document.getElementById('modal-name');
const valProtein = document.getElementById('val-protein');
const valSugar = document.getElementById('val-sugar');
const valFat = document.getElementById('val-fat');
const valPotassium = document.getElementById('val-potassium');
const valPhosphorus = document.getElementById('val-phosphorus');
const valSalt = document.getElementById('val-salt');
const valCalcium = document.getElementById('val-calcium');

// Terms Elements
const termsModal = document.getElementById('terms-modal');
const closeTermsBtn = document.getElementById('close-terms');
const acceptTermsBtn = document.getElementById('accept-terms-btn');
const termsContentDiv = document.getElementById('terms-content');
const openTermsLink = document.getElementById('open-terms');

// Language Functions
function updateLanguage(lang) {
    currentLang = lang;
    const t = translations[lang];
    if (!t) return;

    // Update Text Elements
    document.querySelectorAll('[data-i18n]').forEach(el => {
        const key = el.getAttribute('data-i18n');
        if (t[key]) el.textContent = t[key];
    });

    // Update Placeholders
    document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
        const key = el.getAttribute('data-i18n-placeholder');
        if (t[key]) el.placeholder = t[key];
    });

    // Update Grid if loaded
    if (foodDatabase.length > 0) {
        filterAndRender();
    }

    // Update Auth Modal Texts if open or just in general to be safe
    // We pass the current state (isRegistering) to refresh texts
    if (document.getElementById('auth-modal')) {
        toggleAuthMode(isRegistering);
    }

    // Update Terms Content if modal is open (so it switches language dynamically)
    if (termsContentDiv) {
        termsContentDiv.innerHTML = translations[currentLang].termsContent;
    }

    setupValidation();
}

function clearError(e) {
    e.target.classList.remove('input-error');
    const checkboxGroup = document.querySelector('.checkbox-group');
    if (checkboxGroup) checkboxGroup.classList.remove('checkbox-error');
}

function setupValidation() {
    const inputs = document.querySelectorAll('#auth-form input');
    inputs.forEach(input => {
        // Clear custom error style on input
        input.addEventListener('input', clearError);
        // Also clear on change (for date/checkbox)
        input.addEventListener('change', clearError);
    });
}

function getFoodName(food) {
    if (food.names && food.names[currentLang]) {
        return food.names[currentLang];
    }
    return food.name;
}

// Custom Select Logic (Generic)
function setupCustomSelects() {
    const customSelects = document.querySelectorAll('.custom-select');

    customSelects.forEach(selectContainer => {
        const selected = selectContainer.querySelector('.select-selected');
        const items = selectContainer.querySelector('.select-items');
        const options = selectContainer.querySelectorAll('.select-items div');
        const hiddenInput = selectContainer.querySelector('input[type="hidden"]'); // For form usage

        // Toggle dropdown
        selected.addEventListener('click', function (e) {
            e.stopPropagation();
            closeAllSelects(this); // Close others
            this.classList.toggle('select-arrow-active');
            items.classList.toggle('select-hide');
        });

        // Handle option click
        options.forEach(option => {
            option.addEventListener('click', function (e) {
                e.stopPropagation();
                const value = this.getAttribute('data-value');
                const isLanguage = selectContainer.id === 'language-select';

                // Update UI
                if (isLanguage) {
                    // For language, we keep the HTML (img + text)
                    selected.innerHTML = this.innerHTML;
                    // Update app language
                    updateLanguage(value);
                } else {
                    // For others (treatment), we act like a select
                    // Update text and keep translation key if exists
                    const key = this.getAttribute('data-i18n');
                    if (key) {
                        selected.setAttribute('data-i18n', key);
                        selected.textContent = translations[currentLang][key] || this.textContent;
                    } else {
                        selected.textContent = this.textContent;
                        selected.removeAttribute('data-i18n');
                    }

                    // Update hidden input if exists
                    if (hiddenInput) {
                        hiddenInput.value = value;
                        hiddenInput.dispatchEvent(new Event('change', { bubbles: true }));
                    }

                    selected.classList.add('selected-value');
                }

                // Close dropdown
                items.classList.add('select-hide');
                selected.classList.remove('select-arrow-active');
            });
        });
    });

    // Close when clicking outside
    document.addEventListener('click', function (e) {
        closeAllSelects(null);
    });
}

function closeAllSelects(elmnt) {
    /* A function that will close all select boxes in the document,
    except the current select box: */
    const items = document.querySelectorAll('.select-items');
    const selecteds = document.querySelectorAll('.select-selected');

    for (let i = 0; i < selecteds.length; i++) {
        if (elmnt == selecteds[i]) {
            continue;
        }
        selecteds[i].classList.remove('select-arrow-active');
    }
    for (let i = 0; i < items.length; i++) {
        if (elmnt == items[i].parentElement.querySelector('.select-selected')) {
            continue;
        }
        items[i].classList.add('select-hide');
    }
}

// Initialization
async function init() {
    try {
        const response = await fetch('/api/foods');
        if (!response.ok) throw new Error('Error al cargar datos');
        foodDatabase = await response.json();

        // Setup Logic
        setupEventListeners();
        setupCustomSelects(); // Updated generic function
        renderTabs(); // Render filters

        // Check for Reset Token in URL
        const urlParams = new URLSearchParams(window.location.search);
        const resetToken = urlParams.get('reset_token');
        if (resetToken) {
            openAuthModal(false, true); // Custom function behavior or manual
            // Manually show Reset View
            document.getElementById('auth-modal').style.display = 'block';
            authBody.style.display = 'none';
            forgotView.style.display = 'none';
            resetView.style.display = 'block';

            // Handle Reset Submit
            resetForm.onsubmit = async (e) => {
                e.preventDefault();
                const newPassword = document.getElementById('reset-new-password').value;
                resetError.textContent = '';
                resetMsg.style.display = 'none';

                try {
                    const res = await fetch('/api/reset_password', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ token: resetToken, password: newPassword })
                    });
                    const data = await res.json();

                    if (data.status === 'success') {
                        resetMsg.textContent = translations[currentLang].passwordChanged;
                        resetMsg.style.display = 'block';
                        setTimeout(() => {
                            // Clear URL
                            window.history.replaceState({}, document.title, "/");
                            // Go to login logic
                            resetView.style.display = 'none';
                            authBody.style.display = 'block';
                            toggleAuthMode(false); // Switch to login
                        }, 2000);
                    } else {
                        resetError.textContent = data.message || "Error";
                    }
                } catch (err) {
                    resetError.textContent = "Error de conexión";
                }
            };
        }


        // Default render
        filterAndRender();

        // Initial Lang
        updateLanguage('es');

        // Set max date for inputs to today
        const todayStr = new Date().toISOString().split('T')[0];
        const dateInputs = document.querySelectorAll('input[type="date"]');
        dateInputs.forEach(input => input.max = todayStr);

    } catch (error) {
        console.error("Error cargando alimentos:", error);
        if (gridContainer) {
            gridContainer.innerHTML = '<p>Error al cargar los alimentos. Asegúrate de que el servidor (server.py) esté corriendo.</p>';
        }
    }
}

function renderTabs() {
    categoryTabsContainer.innerHTML = '';
    categories.forEach(cat => {
        const btn = document.createElement('button');
        btn.className = `category-tab ${cat.id === activeCategory ? 'active' : ''}`;
        btn.textContent = cat.label; // Will be updated by translate
        btn.setAttribute('data-i18n', cat.key);
        btn.setAttribute('data-cat', cat.id);

        btn.addEventListener('click', () => {
            activeCategory = cat.id;

            // Update UI
            document.querySelectorAll('.category-tab').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');

            filterAndRender();
        });

        categoryTabsContainer.appendChild(btn);
    });
}

// Helper to remove accents/diacritics
function normalizeText(text) {
    if (!text) return "";
    return text.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase();
}

function filterAndRender() {
    const searchTerm = normalizeText(searchInput.value.trim());

    const filtered = foodDatabase.filter(food => {
        // Text Match (Accent and Case Insensitive)
        const name = getFoodName(food);
        const matchesText = normalizeText(name).includes(searchTerm);

        // Category Match (Supporting comma-separated strings)
        const matchesCategory = activeCategory === 'all' ||
            food.category === activeCategory ||
            (food.category && food.category.split(',').map(c => c.trim()).includes(activeCategory));

        return matchesText && matchesCategory;
    });

    renderGrid(filtered);
}

// Render Logic
function renderGrid(foodsToRender) {
    gridContainer.innerHTML = '';
    if (foodsToRender.length === 0) {
        gridContainer.innerHTML = '<p style="text-align: center; width: 100%; color: #888;">No se encontraron alimentos.</p>';
        return;
    }

    foodsToRender.forEach(food => {
        const card = document.createElement('div');
        card.className = 'food-card';
        card.innerHTML = `
            <img src="${food.image}" alt="${getFoodName(food)}">
            <h3>${getFoodName(food)}</h3>
        `;
        card.addEventListener('click', () => openModal(food));
        gridContainer.appendChild(card);
    });
}

function openModal(food) {
    currentFood = food;
    gramsInput.value = '';
    mImg.src = food.image;
    mName.textContent = getFoodName(food);
    updateNutrients(0);
    modal.classList.add('active');
    gramsInput.focus();
}

function closeModal() {
    modal.classList.remove('active');
    currentFood = null;
}

function openFeedback() {
    feedbackModal.classList.add('active');
    feedbackText.focus();
}

function closeFeedback() {
    feedbackModal.classList.remove('active');
}

async function sendFeedback() {
    const text = feedbackText.value.trim();
    if (!text) return;

    // Visual feedback immediately
    const originalText = sendFeedbackBtn.textContent;
    sendFeedbackBtn.textContent = "...";

    try {
        const response = await fetch('/api/feedback', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ message: text })
        });

        if (response.ok) {
            console.log("Feedback enviado servidor");

            // Success State
            sendFeedbackBtn.textContent = (currentLang === 'es' ? '¡Enviado!' : 'Sent!');
            sendFeedbackBtn.style.background = '#10b981'; // Green

            setTimeout(() => {
                feedbackText.value = '';
                closeFeedback();
                // Reset button style
                setTimeout(() => {
                    sendFeedbackBtn.textContent = translations[currentLang].send;
                    sendFeedbackBtn.style.background = '';
                }, 500);
            }, 1000);
        } else {
            throw new Error('Server error');
        }
    } catch (error) {
        console.error("Error enviando feedback:", error);
        sendFeedbackBtn.textContent = "Error";
        setTimeout(() => {
            sendFeedbackBtn.textContent = translations[currentLang].send;
        }, 2000);
    }
}

function setupEventListeners() {
    closeModalBtn.addEventListener('click', closeModal);
    window.addEventListener('click', (e) => {
        if (e.target === modal) closeModal();
        if (e.target === feedbackModal) closeFeedback();
    });

    gramsInput.addEventListener('input', (e) => {
        updateNutrients(parseFloat(e.target.value) || 0);
    });

    searchInput.addEventListener('input', (e) => {
        filterAndRender();
    });

    // Feedback Listeners
    feedbackBtn.addEventListener('click', openFeedback);
    closeFeedbackBtn.addEventListener('click', closeFeedback);
    cancelFeedbackBtn.addEventListener('click', closeFeedback);
    sendFeedbackBtn.addEventListener('click', sendFeedback);

    // Terms Listeners
    if (openTermsLink) {
        openTermsLink.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (termsContentDiv) {
                termsContentDiv.innerHTML = translations[currentLang].termsContent;
            }
            termsModal.classList.add('active');
        });
    }

    if (closeTermsBtn) {
        closeTermsBtn.addEventListener('click', () => {
            termsModal.classList.remove('active');
        });
    }

    if (acceptTermsBtn) {
        acceptTermsBtn.addEventListener('click', () => {
            termsModal.classList.remove('active');
            // Optionally check the box automatically?
            // document.getElementById('terms-check').checked = true;
        });
    }
}

// --- Nephrologist Logic ---
class Nephrologist {
    static getTrafficColor(nutrient, value, userProfile) {
        if (!userProfile) return ''; // Default color if no profile

        const v = parseFloat(value);
        if (isNaN(v)) return '';

        // Check Insufficiency Flag
        // It might be stored as '1', 1, true, or 'true'
        const hasInsufficiency = userProfile.has_insufficiency === '1' || userProfile.has_insufficiency === 1 || userProfile.has_insufficiency === true || userProfile.has_insufficiency === 'true';

        // 1. HEALTHY / NO INSUFFICIENCY
        // If user says "No" to insufficiency, we use standard healthy adult guidelines (very loose for these specific renal nutrients)
        if (!hasInsufficiency) {
            // Healthy limits (per meal approx)
            // Potassium: RDA ~4700mg/day -> ~1500mg/meal is fine.
            // Phosphorus: RDA ~700mg/day -> ~250mg is norm, but high P isn't toxic for healthy kidneys usually.
            // Protein: 20-30g is standard meal. High protein is fine.
            // Salt: <6g/day -> <2g/meal.

            // We only warn if it's REALLY high (Traffic Light for General Population)
            const healthyLimits = {
                potassium: { green: 1000, yellow: 2000 },
                phosphorus: { green: 500, yellow: 1000 },
                protein: { green: 40, yellow: 80 },
                salt: { green: 1.5, yellow: 3.0 },
                calcium: { green: 400, yellow: 800 }
            };

            if (v <= healthyLimits[nutrient].green) return 'traffic-green';
            if (v <= healthyLimits[nutrient].yellow) return 'traffic-yellow';
            return 'traffic-red';
        }

        // 2. RENAL INSUFFICIENCY LOGIC
        // Default Renal Limits (Conservative baseline)
        let limits = {
            potassium: { green: 200, yellow: 400 }, // mg - Strict
            phosphorus: { green: 150, yellow: 300 }, // mg - Strict
            protein: { green: 10, yellow: 25 },    // g - Low Protein baseline
            salt: { green: 0.5, yellow: 1.2 },     // g
            calcium: { green: 100, yellow: 300 }    // mg
        };

        const stage = userProfile.kidney_stage; // 1, 2, 3a, 3b, 4, 5
        const treatment = userProfile.treatment_type; // dialysis, transplant, erca

        // ADJUSTMENTS BY STAGE/TREATMENT

        // A) STAGE 1-2 (Mild) OR Functional Transplant
        // Usually less restrictions unless specific lab values are off.
        if (['1', '2', '3a'].includes(stage)) {
            // General "Good Function" limits
            limits.potassium = { green: 400, yellow: 800 };
            limits.phosphorus = { green: 300, yellow: 600 };
            limits.protein = { green: 20, yellow: 40 };

            // If Transplant specific adjustments needed, they can be here.
            // But generally, Stage 1-2 Transplant is similar to Stage 1-2 Native for these nutrients.
        }

        // B) STAGE 3b-4 (Pre-dialysis) -> Strict
        // Applies to Native AND Transplant with failing function
        if (['3b', '4'].includes(stage) && treatment !== 'dialysis') {
            limits.potassium = { green: 200, yellow: 400 };
            limits.phosphorus = { green: 150, yellow: 300 };
            limits.protein = { green: 10, yellow: 25 };
            limits.salt = { green: 0.5, yellow: 1.0 };
        }

        // B.2) STAGE 5 (Pre-dialysis) -> Very Strict
        // Applies to Native AND Transplant with failing function
        if (stage === '5' && treatment !== 'dialysis') {
            limits.potassium = { green: 150, yellow: 350 };
            limits.phosphorus = { green: 120, yellow: 250 };
            limits.protein = { green: 8, yellow: 20 };
            limits.salt = { green: 0.4, yellow: 0.8 };
        }

        // C) DIALYSIS (Overrides everything)
        if (treatment === 'dialysis') {
            limits.potassium = { green: 200, yellow: 500 };
            limits.phosphorus = { green: 200, yellow: 400 };
            limits.protein = { green: 60, yellow: 100 };
        }

        // D) TRANSPLANT (Specifics)
        // Only apply "Transplant Loose Rules" if we haven't already hit a strict stage criteria
        // or if we are in the "Good Function" zone.
        if (treatment === 'transplant' && ['1', '2', '3a'].includes(stage)) {
            // Transplant patients often have slightly better tolerance or diff meds
            // but let's just ensure they are loose.
            limits.potassium = { green: 800, yellow: 1500 };
            limits.phosphorus = { green: 400, yellow: 800 };
            limits.protein = { green: 30, yellow: 60 };
            // Note: This overrides Block A for these stages.
        }

        // Get Color
        if (v <= limits[nutrient].green) return 'traffic-green';
        if (v <= limits[nutrient].yellow) return 'traffic-yellow';
        return 'traffic-red';
    }
}

function updateNutrients(grams) {
    if (!currentFood) return;
    const ratio = grams / 100;
    const n = currentFood.nutrients;

    // Calculate raw values
    const vProteins = (n.protein * ratio).toFixed(1);
    const vSugar = (n.sugar * ratio).toFixed(1);
    const vFat = (n.fat * ratio).toFixed(1);
    const vPotassium = (n.potassium * ratio).toFixed(0);
    const vPhosphorus = (n.phosphorus * ratio).toFixed(0);
    const vSalt = (n.salt * ratio).toFixed(2);
    const vCalcium = (n.calcium * ratio).toFixed(0);

    // Update Text
    valProtein.textContent = vProteins + 'g';
    valSugar.textContent = vSugar + 'g';
    valFat.textContent = vFat + 'g';
    valPotassium.textContent = vPotassium + 'mg';
    valPhosphorus.textContent = vPhosphorus + 'mg';
    valSalt.textContent = vSalt + 'g';
    valCalcium.textContent = vCalcium + 'mg'; // Fixed typo in variable name if existing

    // Apply Colors
    const user = localStorage.getItem('user') ? JSON.parse(localStorage.getItem('user')) : null;

    // Reset classes
    [valProtein, valPotassium, valPhosphorus, valSalt, valCalcium].forEach(el => {
        el.classList.remove('traffic-green', 'traffic-yellow', 'traffic-red');
        // Also remove any default colors text-xxx if present (though we removed them from CSS)
    });

    // Apply new classes
    if (user) {
        valProtein.classList.add(Nephrologist.getTrafficColor('protein', vProteins, user));
        valPotassium.classList.add(Nephrologist.getTrafficColor('potassium', vPotassium, user));
        valPhosphorus.classList.add(Nephrologist.getTrafficColor('phosphorus', vPhosphorus, user));
        valSalt.classList.add(Nephrologist.getTrafficColor('salt', vSalt, user));
        valCalcium.classList.add(Nephrologist.getTrafficColor('calcium', vCalcium, user));
    }
}

// --- Auth Logic ---
const authModal = document.getElementById('auth-modal');
const closeAuthBtn = document.getElementById('close-auth');
const userBtn = document.getElementById('user-btn');
const authForm = document.getElementById('auth-form');
const tabLogin = document.getElementById('tab-login');
const tabRegister = document.getElementById('tab-register');
const nameGroup = document.getElementById('register-fields');
const authTitle = document.getElementById('auth-title');
const authSubmit = document.getElementById('auth-submit');
const switchRegister = document.getElementById('switch-to-register');
const authError = document.getElementById('auth-error');

let isRegistering = false;

function setupAuth() {
    if (!userBtn) return;

    userBtn.addEventListener('click', (e) => {
        e.stopPropagation(); // Prevent bubbling causing immediate close
        const storedUser = localStorage.getItem('user');
        if (storedUser) {
            // Logged In -> Toggle Dropdown
            const dropdown = document.getElementById('user-dropdown');
            dropdown.classList.toggle('active');
        } else {
            // Logged Out -> Open Auth Modal
            // RESET STATE: Always show login/main view
            if (document.getElementById('auth-form')) document.getElementById('auth-form').style.display = 'block';
            if (document.getElementById('forgot-password-view')) document.getElementById('forgot-password-view').style.display = 'none';
            if (document.getElementById('reset-password-view')) document.getElementById('reset-password-view').style.display = 'none';

            // Ensure tabs are visible
            const tabs = document.querySelector('.auth-tabs');
            if (tabs) tabs.style.display = 'flex';

            // Reset to Login Mode by default
            toggleAuthMode(false);

            authModal.classList.add('active');
        }
    });

    closeAuthBtn.addEventListener('click', () => {
        authModal.classList.remove('active');
    });

    tabLogin.addEventListener('click', () => toggleAuthMode(false));
    tabRegister.addEventListener('click', () => toggleAuthMode(true));

    if (switchRegister) {
        switchRegister.addEventListener('click', (e) => {
            e.preventDefault();
            toggleAuthMode(!isRegistering);
        });
    }

    authForm.addEventListener('submit', handleAuthSubmit);

    // Check if logged in
    const storedUser = localStorage.getItem('user');
    if (storedUser) {
        const user = JSON.parse(storedUser);
        console.log("Logged in as:", user.name);
        userBtn.classList.add('user-logged-in'); // Ensure styled logged in
        if (user.avatar_url) {
            updateUserAvatar(user.avatar_url);
        } else {
            updateUserAvatar('images/default_avatar.png');
        }
    }

    setupDropdownListeners();
}

function setupDropdownListeners() {
    const userDropdown = document.getElementById('user-dropdown');
    const profileBtn = document.getElementById('profile-btn');
    const logoutBtn = document.getElementById('logout-btn');

    if (profileBtn) {
        profileBtn.addEventListener('click', async (e) => {
            e.stopPropagation();
            userDropdown.classList.remove('active');

            // Sync with DB
            const storedUser = localStorage.getItem('user');
            if (storedUser) {
                try {
                    const localUser = JSON.parse(storedUser);
                    const res = await fetch(`/api/get_user?id=${localUser.id}`);
                    if (res.ok) {
                        const freshData = await res.json();
                        // Merge fresh data
                        const mergedUser = { ...localUser, ...freshData };
                        localStorage.setItem('user', JSON.stringify(mergedUser));
                    }
                } catch (err) {
                    console.error("Error syncing profile:", err);
                }
            }

            loadProfileData(); // Pre-fill data
            document.getElementById('medical-modal').classList.add('active'); // Open Modal
        });
    }

    if (logoutBtn) {
        logoutBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            userDropdown.classList.remove('active');
            logout();
        });
    }

    // Close dropdown when clicking outside
    window.addEventListener('click', (e) => {
        if (userDropdown && userDropdown.classList.contains('active')) {
            // If click is NOT on userBtn and NOT on dropdown, close it
            if (!userBtn.contains(e.target) && !userDropdown.contains(e.target)) {
                userDropdown.classList.remove('active');
            }
        }
    });
}

function logout() {
    localStorage.removeItem('user');
    location.reload(); // Simple reload to clear state
}

function updateUserAvatar(url) {
    const userBtn = document.getElementById('user-btn');
    const avatarImg = document.getElementById('user-avatar-img');

    if (userBtn && avatarImg) {
        userBtn.classList.add('has-avatar');
        // Cache busting
        if (url.includes('?')) {
            avatarImg.src = `${url}&t=${new Date().getTime()}`;
        } else {
            avatarImg.src = `${url}?t=${new Date().getTime()}`;
        }
    }
}

function toggleAuthMode(register) {
    isRegistering = register;
    authError.textContent = '';
    const t = translations[currentLang];

    if (isRegistering) {
        tabLogin.classList.remove('active');
        tabRegister.classList.add('active');
        nameGroup.style.display = 'block';
        // Simple localization for now, ideally use translation keys
        authTitle.textContent = t.createAccount;
        authSubmit.textContent = t.registerBtn;
        const footer = document.getElementById('auth-footer-text');
        if (footer) footer.style.display = 'none';

        document.getElementById('auth-name').required = true;
        document.getElementById('auth-surnames').required = true;
        document.getElementById('auth-birthdate').required = true;

        const forgotLink = document.getElementById('forgot-password-link-container');
        if (forgotLink) forgotLink.style.display = 'none';

    } else {
        tabRegister.classList.remove('active');
        tabLogin.classList.add('active');
        nameGroup.style.display = 'none';
        authTitle.textContent = t.welcomeBack;
        authSubmit.textContent = t.loginBtn;

        const footer = document.getElementById('auth-footer-text');
        if (footer) {
            footer.style.display = 'block';
            const span = footer.querySelector('span');
            const link = footer.querySelector('a');
            if (span) span.textContent = t.noAccount;
            if (link) link.textContent = t.registerLink;
        }

        document.getElementById('auth-name').required = false;
        document.getElementById('auth-surnames').required = false;
        document.getElementById('auth-birthdate').required = false;

        const forgotLink = document.getElementById('forgot-password-link-container');
        if (forgotLink) forgotLink.style.display = 'block';
    }
}

async function handleAuthSubmit(e) {
    e.preventDefault();
    authError.textContent = '';
    authSubmit.disabled = true;

    const email = document.getElementById('auth-email').value;
    const password = document.getElementById('auth-password').value;
    const name = document.getElementById('auth-name').value;
    const surnames = document.getElementById('auth-surnames').value;
    const birthdate = document.getElementById('auth-birthdate').value;

    const endpoint = isRegistering ? '/api/register' : '/api/login';
    const payload = { email, password };

    // --- MANUAL VALIDATION ---
    let isValid = true;
    let firstInvalid = null;

    // Helper to mark invalid
    const markInvalid = (id) => {
        const el = document.getElementById(id);
        if (el) {
            el.classList.add('input-error');
            if (!firstInvalid) firstInvalid = el;
        }
        isValid = false;
    };

    if (!email) markInvalid('auth-email');
    if (!password) markInvalid('auth-password');

    if (isRegistering) {
        if (!name) markInvalid('auth-name');
        if (!surnames) markInvalid('auth-surnames');
        if (!birthdate) markInvalid('auth-birthdate');

        // Terms Validation
        const termsCheck = document.getElementById('terms-check');
        if (!termsCheck.checked) {
            const group = document.querySelector('.checkbox-group');
            if (group) group.classList.add('checkbox-error');
            isValid = false;
            // Specific error for terms if it's the only thing missing, otherwise generic
            if (!firstInvalid) {
                authError.textContent = translations[currentLang].validationTerms;
                authSubmit.disabled = false;
                return;
            }
        }
    }

    if (!isValid) {
        authError.textContent = translations[currentLang].validationGeneric;
        if (firstInvalid) firstInvalid.focus();
        authSubmit.disabled = false;
        return;
    }
    // -------------------------

    // Validate email format
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
        authError.textContent = translations[currentLang].validationEmail;
        authSubmit.disabled = false;
        return;
    }

    if (isRegistering) {
        // Terms checked above

        payload.name = name;
        payload.surnames = surnames;
        payload.birthdate = birthdate;

        // Validate birthdate
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const birthDateObj = new Date(birthdate);

        if (birthDateObj > today) {
            authError.textContent = 'La fecha de nacimiento no puede ser futura.';
            authSubmit.disabled = false;
            return;
        }
    }

    try {
        const res = await fetch(endpoint, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });

        const data = await res.json();

        if (res.ok) {
            // Success
            const userData = {
                id: data.userId,
                name: data.name,
                surnames: data.surnames,
                birthdate: data.birthdate,
                has_insufficiency: data.has_insufficiency,
                treatment_type: data.treatment_type,
                kidney_stage: data.kidney_stage,
                email: email,
                avatar_url: data.avatar_url || 'images/default_avatar.png'
            };

            localStorage.setItem('user', JSON.stringify(userData));
            authModal.classList.remove('active');
            userBtn.classList.add('user-logged-in');

            updateUserAvatar(userData.avatar_url);

            if (isRegistering) {
                const medicalModal = document.getElementById('medical-modal');
                if (medicalModal) {
                    // Hide email and password in first-setup flow
                    const emailGroup = document.getElementById('profile-email-group');
                    const passGroup = document.getElementById('profile-password-group');
                    if (emailGroup) emailGroup.style.display = 'none';
                    if (passGroup) passGroup.style.display = 'none';

                    // Pre-fill data from the just-created user
                    loadProfileData();

                    medicalModal.classList.add('active');
                }
            } else {
                alert(`Hola ${data.name}!`);
            }
            authForm.reset();
        } else {
            authError.textContent = data.message || 'Error';
        }
    } catch (err) {
        console.error(err);
        authError.textContent = 'Error de conexión';
    } finally {
        authSubmit.disabled = false;
    }
}

// Modify init to include setupAuth
// --- Medical Profile Logic ---
function setupMedical() {
    const medicalForm = document.getElementById('medical-form');
    if (!medicalForm) return;

    // Avatar Upload Logic
    const avatarInput = document.getElementById('avatar-input');
    const avatarPreview = document.getElementById('avatar-preview');

    if (avatarInput) {
        avatarInput.addEventListener('change', function (e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function (e) {
                    // Update preview
                    avatarPreview.src = e.target.result;
                    // Store pending upload
                    pendingAvatarUpload = e.target.result;
                };
                reader.readAsDataURL(file);
            }
        });
    }

    async function uploadAvatar(email, base64Image) {
        try {
            const res = await fetch('/api/upload_avatar', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    email: email,
                    image_data: base64Image
                })
            });

            if (res.ok) {
                const data = await res.json();
                return data.avatar_url;
            }
        } catch (err) {
            console.error("Error uploading avatar", err);
        }
        return null;
    }

    // Logic for disabling/enabling fields
    const toggle = document.getElementById('insufficiency-toggle');

    if (toggle) {
        toggle.addEventListener('change', updateMedicalVisibility);
        // Init state
        updateMedicalVisibility();
    }

    // Listener for Treatment Change
    const treatmentHidden = document.getElementById('treatment-type-hidden');
    if (treatmentHidden) {
        treatmentHidden.addEventListener('change', updateMedicalVisibility);
    }

    // Close button for medical modal
    const closeMedicalBtn = document.getElementById('close-medical');
    if (closeMedicalBtn) {
        closeMedicalBtn.style.display = 'block'; // Ensure it's visible now
        closeMedicalBtn.addEventListener('click', () => {
            document.getElementById('medical-modal').classList.remove('active');
        });
    }

    // Cancel Button Logic
    const cancelMedicalBtn = document.getElementById('cancel-medical');
    if (cancelMedicalBtn) {
        cancelMedicalBtn.addEventListener('click', () => {
            document.getElementById('medical-modal').classList.remove('active');
        });
    }

    medicalForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const errorMsg = document.getElementById('medical-error');
        const submitBtn = document.getElementById('save-medical');
        errorMsg.textContent = '';
        submitBtn.disabled = true;

        // Get user from local storage
        const storedUser = localStorage.getItem('user');
        if (!storedUser) {
            errorMsg.textContent = 'Error: Usuario no identificado';
            submitBtn.disabled = false;
            return;
        }
        let user = JSON.parse(storedUser);

        // Gather Data
        const name = document.getElementById('profile-name').value;
        const surnames = document.getElementById('profile-surnames').value;
        const birthdate = document.getElementById('profile-birthdate').value;
        const password = document.getElementById('profile-password').value; // Optional
        const insufficiency = toggle && toggle.checked ? '1' : '0';

        // Only gather other data if insufficiency is YES
        let treatment = null;
        let stage = null;

        if (insufficiency === '1') {
            treatment = document.getElementById('treatment-type-hidden').value;
            stage = document.querySelector('input[name="kidney_stage"]:checked')?.value;
        }

        const payload = {
            email: user.email,
            name: name,
            surnames: surnames,
            birthdate: birthdate,
            has_insufficiency: insufficiency,
            treatment_type: treatment || null,
            kidney_stage: stage || null
        };

        if (password) {
            payload.password = password;
        }

        // Validate birthdate
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const birthDateObj = new Date(birthdate);

        if (birthDateObj > today) {
            errorMsg.textContent = 'La fecha de nacimiento no puede ser futura.';
            submitBtn.disabled = false;
            return;
        }

        try {
            const res = await fetch('/api/update_profile', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (res.ok) {
                // Check if we have a pending avatar upload
                if (pendingAvatarUpload) {
                    const newAvatarUrl = await uploadAvatar(user.email, pendingAvatarUpload);
                    if (newAvatarUrl) {
                        user.avatar_url = newAvatarUrl;
                        // Force UI update for avatar immediately
                        updateUserAvatar(newAvatarUrl);
                    }
                }

                // Update local storage
                user.name = name;
                user.surnames = surnames;
                user.birthdate = birthdate;
                user.has_insufficiency = insufficiency;
                user.treatment_type = treatment;
                user.kidney_stage = stage;
                localStorage.setItem('user', JSON.stringify(user));

                document.getElementById('medical-modal').classList.remove('active');

                // Refresh avatar if needed (name display)
                const nameDisplay = document.getElementById('profile-name-display');
                if (nameDisplay) nameDisplay.textContent = user.name + " " + (user.surnames || "");

                // Clear password field
                document.getElementById('profile-password').value = "";

                // Reset pending
                pendingAvatarUpload = null;

                alert(`Perfil actualizado!`);

                // Update current food modal if open to reflect new traffic lights immediately
                if (currentFood && modal.classList.contains('active')) {
                    const currentGrams = parseFloat(gramsInput.value) || 0;
                    updateNutrients(currentGrams);
                }

            } else {
                const data = await res.json();
                errorMsg.textContent = data.message || 'Error al guardar perfil';
            }
        } catch (err) {
            console.error(err);
            errorMsg.textContent = 'Error de conexión';
        } finally {
            submitBtn.disabled = false;
        }
    });
}

function updateMedicalVisibility() {
    const toggle = document.getElementById('insufficiency-toggle');
    const treatmentGroup = document.getElementById('treatment-group');
    const stageGroup = document.getElementById('stage-group');
    const treatmentHidden = document.getElementById('treatment-type-hidden');

    if (!toggle || !treatmentGroup || !stageGroup) return;

    if (toggle.checked) {
        treatmentGroup.classList.remove('disabled-section');
        treatmentGroup.querySelectorAll('input, select, button').forEach(el => el.disabled = false);

        // Check if Dialysis is selected
        if (treatmentHidden && treatmentHidden.value === 'dialysis') {
            stageGroup.classList.add('disabled-section');
            stageGroup.querySelectorAll('input, select, button').forEach(el => el.disabled = true);
            // Optional: clear selection or style it differently? keeping it just disabled for now
        } else {
            stageGroup.classList.remove('disabled-section');
            stageGroup.querySelectorAll('input, select, button').forEach(el => el.disabled = false);
        }
    } else {
        treatmentGroup.classList.add('disabled-section');
        stageGroup.classList.add('disabled-section');
        treatmentGroup.querySelectorAll('input, select, button').forEach(el => el.disabled = true);
        stageGroup.querySelectorAll('input, select, button').forEach(el => el.disabled = true);
    }
}

function loadProfileData() {
    const storedUser = localStorage.getItem('user');
    if (!storedUser) return;
    const user = JSON.parse(storedUser);

    // Reset Pending Avatar
    pendingAvatarUpload = null;
    const avatarInput = document.getElementById('avatar-input');
    if (avatarInput) avatarInput.value = '';

    // Populate Fields
    document.getElementById('profile-name').value = user.name || '';
    document.getElementById('profile-surnames').value = user.surnames || '';
    document.getElementById('profile-birthdate').value = user.birthdate || '';
    document.getElementById('profile-email').value = user.email || '';

    // Ensure Email is visible but disabled
    const emailGroup = document.getElementById('profile-email-group');
    if (emailGroup) {
        emailGroup.style.display = 'block';
        const emInput = document.getElementById('profile-email');
        if (emInput) emInput.disabled = true;
    }

    // Hide Password field when editing profile
    const passGroup = document.getElementById('profile-password-group');
    if (passGroup) passGroup.style.display = 'none';

    const nameDisplay = document.getElementById('profile-name-display');
    if (nameDisplay) nameDisplay.textContent = (user.name || '') + " " + (user.surnames || '');

    if (user.avatar_url) {
        const url = user.avatar_url;
        const timestamp = new Date().getTime();
        document.getElementById('avatar-preview').src = url.includes('?') ? `${url}&t=${timestamp}` : `${url}?t=${timestamp}`;
    }

    // Medical Data
    // Medical Data
    const toggle = document.getElementById('insufficiency-toggle');
    if (toggle) {
        // Handle potentially different types (string '1', number 1, boolean true)
        const val = user.has_insufficiency;
        const isChecked = val === '1' || val === 1 || val === true || val === 'true';
        toggle.checked = isChecked;

        // Trigger visibility update
        updateMedicalVisibility();
    }

    // Show Cancel Button and ensure correct Save Text
    const cancelBtn = document.getElementById('cancel-medical');
    if (cancelBtn) cancelBtn.style.display = 'block';

    const t = translations[currentLang];
    const saveMedicalBtn = document.getElementById('save-medical');
    if (saveMedicalBtn) saveMedicalBtn.textContent = t.saveBtn;

    if (user.treatment_type) {
        // Update custom select
        const select = document.getElementById('treatment-select');
        const hidden = document.getElementById('treatment-type-hidden');
        const selectedText = document.getElementById('treatment-selected-text');

        if (hidden && selectedText && select) {
            hidden.value = user.treatment_type;

            // Find text label deeply
            const option = select.querySelector(`.select-items div[data-value="${user.treatment_type}"]`);
            if (option) {
                const key = option.getAttribute('data-i18n');
                if (key) {
                    selectedText.setAttribute('data-i18n', key);
                    selectedText.textContent = t[key] || option.textContent;
                } else {
                    selectedText.textContent = option.textContent;
                    selectedText.removeAttribute('data-i18n');
                }
                selectedText.classList.add('selected-value');
            }
        }
    }

    if (user.kidney_stage) {
        // Ensure we match string value
        const val = String(user.kidney_stage);
        const radio = document.querySelector(`input[name="kidney_stage"][value="${val}"]`);
        if (radio) {
            radio.checked = true;
            // Force change event if needed for custom styling, though :checked css should pass
            radio.dispatchEvent(new Event('change', { bubbles: true }));
        }
    }
}

// --- Chat Logic ---
// --- Chat Logic ---
function toggleChat() {
    const window = document.getElementById('chat-window');
    window.classList.toggle('active');
    if (window.classList.contains('active')) {
        const input = document.getElementById('chat-input');
        if (input) setTimeout(() => input.focus(), 100);

        // Scroll to bottom on open
        const messages = document.getElementById('chat-messages');
        messages.scrollTop = messages.scrollHeight;
    }
}

function handleChatKey(e) {
    if (e.key === 'Enter') sendChatMessage();
}

function loadChatHistory() {
    const history = localStorage.getItem('chat_history');
    if (history) {
        try {
            const msgs = JSON.parse(history);
            const container = document.getElementById('chat-messages');
            // Clear default welcome message if we have history
            if (msgs.length > 0) container.innerHTML = '';

            msgs.forEach(m => {
                addMessage(m.text, m.className, false); // false to skip saving again
            });
        } catch (e) {
            console.error("Error loading chat history", e);
        }
    }
}

function clearChatHistory() {
    localStorage.removeItem('chat_history');
    document.getElementById('chat-messages').innerHTML = `
        <div class="message ai-message">
            Hola, soy tu asistente virtual. ¿Tienes dudas sobre si puedes comer algún alimento con tu condición actual?
        </div>
    `;
}

async function sendChatMessage() {
    const input = document.getElementById('chat-input');
    const messages = document.getElementById('chat-messages');
    const text = input.value.trim();
    if (!text) return;

    // Add User Message
    addMessage(text, 'user-message');
    input.value = '';

    // Typing Indicator
    const typingId = 'typing-' + Date.now();
    const typingDiv = document.createElement('div');
    typingDiv.id = typingId;
    typingDiv.className = 'typing-indicator';
    typingDiv.textContent = 'Escribiendo...';
    messages.appendChild(typingDiv);
    messages.scrollTop = messages.scrollHeight;

    // Get User ID
    const storedUser = localStorage.getItem('user');
    let userId = null;
    if (storedUser) {
        userId = JSON.parse(storedUser).id;
    }

    // Prepare History (limit to last 12 turns to save context)
    let history = [];
    const rawHistory = localStorage.getItem('chat_history');
    if (rawHistory) {
        try {
            const parsed = JSON.parse(rawHistory);
            // Map to Gemini Format matching server expectations
            // 'user-message' -> 'user', 'ai-message' -> 'model'
            history = parsed.slice(-12).map(msg => ({
                role: msg.className === 'user-message' ? 'user' : 'model',
                text: msg.text
            }));
        } catch (e) {
            console.error("Error parsing history for API", e);
        }
    }

    try {
        const res = await fetch('/api/chat', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                message: text,
                userId: userId,
                history: history
            })
        });

        const data = await res.json();
        const typingEl = document.getElementById(typingId);
        if (typingEl) typingEl.remove();

        if (data.response) {
            addMessage(data.response, 'ai-message');
        } else if (data.error) {
            if (currentLang === 'es') {
                addMessage("Lo siento, hubo un error técnico (" + (data.details?.error || "Desconocido") + "). Inténtalo de nuevo.", 'ai-message');
            } else {
                addMessage("Sorry, there was a technical error. Please try again.", 'ai-message');
            }
        }
    } catch (err) {
        console.error(err);
        const typingEl = document.getElementById(typingId);
        if (typingEl) typingEl.remove();
        addMessage("Error de conexión.", 'ai-message');
    }
}

function addMessage(text, className, save = true) {
    const messages = document.getElementById('chat-messages');
    const div = document.createElement('div');
    div.className = `message ${className}`;
    // Simple formatting
    let formatted = text.replace(/\n/g, '<br>');
    div.innerHTML = formatted;
    messages.appendChild(div);
    messages.scrollTop = messages.scrollHeight;

    if (save) {
        const history = localStorage.getItem('chat_history') ? JSON.parse(localStorage.getItem('chat_history')) : [];
        history.push({ text: text, className: className, timestamp: Date.now() });
        // Limit history to 50 messages to avoid huge localStorage
        if (history.length > 50) history.shift();
        localStorage.setItem('chat_history', JSON.stringify(history));
    }
}

// Password Reset Logic
function setupPasswordReset() {
    // 1. View Switching
    if (forgotPasswordBtn) {
        forgotPasswordBtn.addEventListener('click', () => {
            if (authBody) authBody.style.display = 'none';
            if (forgotView) forgotView.style.display = 'block';
            if (resetView) resetView.style.display = 'none';
        });
    }

    if (backToLoginBtn) {
        backToLoginBtn.addEventListener('click', () => {
            if (authBody) authBody.style.display = 'block';
            if (forgotView) forgotView.style.display = 'none';
            if (resetView) resetView.style.display = 'none';
            toggleAuthMode(false);
        });
    }

    // 2. Forgot Request Submit
    if (forgotForm) {
        forgotForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const email = document.getElementById('forgot-email').value;
            forgotError.textContent = '';
            forgotMsg.style.display = 'none';

            try {
                const res = await fetch('/api/request_password_reset', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ email })
                });
                // Always show success to avoid enumeration
                forgotMsg.textContent = translations[currentLang].linkSent;
                forgotMsg.style.display = 'block';
            } catch (err) {
                forgotMsg.textContent = translations[currentLang].linkSent; // Fake success on error too? Or generic error.
                forgotMsg.style.display = 'block';
            }
        });
    }

    // 3. Check for Reset Token in URL
    const urlParams = new URLSearchParams(window.location.search);
    const resetToken = urlParams.get('reset_token');

    if (resetToken) {
        // Open Modal
        openAuthModal(false, true);

        // Ensure Reset View is visible
        setTimeout(() => {
            const authModal = document.getElementById('auth-modal');
            if (authModal) authModal.style.display = 'block';

            if (authBody) authBody.style.display = 'none';
            if (forgotView) forgotView.style.display = 'none';
            if (resetView) resetView.style.display = 'block';
        }, 100);

        // Handle Reset Submit
        if (resetForm) {
            resetForm.onsubmit = async (e) => {
                e.preventDefault();
                const newPassword = document.getElementById('reset-new-password').value;
                resetError.textContent = '';
                resetMsg.style.display = 'none';

                try {
                    const res = await fetch('/api/reset_password', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ token: resetToken, password: newPassword })
                    });
                    const data = await res.json();

                    if (data.status === 'success') {
                        resetMsg.textContent = translations[currentLang].passwordChanged;
                        resetMsg.style.display = 'block';
                        setTimeout(() => {
                            // Clear URL
                            window.history.replaceState({}, document.title, "/");
                            // Go back to login
                            if (resetView) resetView.style.display = 'none';
                            if (authBody) authBody.style.display = 'block';
                            toggleAuthMode(false);
                        }, 2000);
                    } else {
                        resetError.textContent = data.message || "Error";
                    }
                } catch (err) {
                    resetError.textContent = "Error de conexión";
                }
            };
        }
    }
}

// FIX: New Robust Password Reset Logic (Version 4 - Final Definitive)
function setupPasswordResetFixed() {
    console.log("Initializing setupPasswordResetFixed...");

    // 1. Define elements safely
    const forgotPasswordBtn = document.getElementById('forgot-password-btn');
    const authForm = document.getElementById('auth-form');
    const forgotView = document.getElementById('forgot-password-view');
    const resetView = document.getElementById('reset-password-view');
    const backToLoginBtn = document.getElementById('back-to-login');
    const forgotForm = document.getElementById('forgot-form');
    const resetForm = document.getElementById('reset-form');
    const authModal = document.getElementById('auth-modal');
    // authBody is used in toggleAuthMode, but here we can rely on specific view toggling

    // Helper to switch views explicitly
    const switchView = (viewName) => {
        console.log("Switching view to:", viewName);
        // Hide all known auth views first
        if (authForm) authForm.style.display = 'none';
        if (forgotView) forgotView.style.display = 'none';
        if (resetView) resetView.style.display = 'none';

        // Handle tabs if present
        const tabs = document.querySelector('.auth-tabs');
        if (tabs) tabs.style.display = 'none';

        // Show specific view
        if (viewName === 'main') {
            if (authForm) authForm.style.display = 'block';
            if (tabs) tabs.style.display = 'flex';
        } else if (viewName === 'forgot') {
            if (forgotView) forgotView.style.display = 'block';
        } else if (viewName === 'reset') {
            if (resetView) resetView.style.display = 'block';
        }
    };

    // 2. Setup Listeners
    if (forgotPasswordBtn) {
        // Clone and replace to remove old listeners if any
        const newBtn = forgotPasswordBtn.cloneNode(true);
        forgotPasswordBtn.parentNode.replaceChild(newBtn, forgotPasswordBtn);

        newBtn.addEventListener('click', (e) => {
            e.preventDefault();
            switchView('forgot');
        });
    }

    if (backToLoginBtn) {
        // Clone and replace
        const newBtn = backToLoginBtn.cloneNode(true);
        backToLoginBtn.parentNode.replaceChild(newBtn, backToLoginBtn);

        newBtn.addEventListener('click', (e) => {
            e.preventDefault();
            switchView('main');
        });
    }

    // 3. Handle Forgot Request
    if (forgotForm) {
        forgotForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const emailElem = document.getElementById('forgot-email');
            const email = emailElem ? emailElem.value : '';
            const forgotMsg = document.getElementById('forgot-msg');
            const forgotError = document.getElementById('forgot-error');

            if (forgotError) forgotError.textContent = '';
            if (forgotMsg) forgotMsg.style.display = 'none';

            try {
                const res = await fetch('/api/request_password_reset', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ email })
                });
                // Always show success to avoid enumeration
                if (forgotMsg) {
                    const text = (translations[currentLang] && translations[currentLang].linkSent) || "Enlace enviado";
                    forgotMsg.textContent = text;
                    forgotMsg.style.display = 'block';
                }
            } catch (err) {
                if (forgotMsg) {
                    const text = (translations[currentLang] && translations[currentLang].linkSent) || "Enlace enviado";
                    forgotMsg.textContent = text;
                    forgotMsg.style.display = 'block';
                }
            }
        });
    }

    // 4. Handle Reset Token from URL
    const urlParams = new URLSearchParams(window.location.search);
    const resetToken = urlParams.get('reset_token');

    if (resetToken) {
        console.log("Reset token found:", resetToken);
        // Force Modal to Open
        if (authModal) {
            authModal.classList.add('active');
            authModal.style.display = 'flex'; // Ensure flex layout for centering
        }

        // Switch to Reset View with slight delay to allow modal render
        setTimeout(() => {
            switchView('reset');
        }, 100);

        // Handle Reset Password Submit
        if (resetForm) {
            resetForm.onsubmit = async (e) => {
                e.preventDefault();
                const passElem = document.getElementById('reset-new-password');
                const newPassword = passElem ? passElem.value : '';
                const resetMsg = document.getElementById('reset-msg');
                const resetError = document.getElementById('reset-error');

                if (resetError) resetError.textContent = '';
                if (resetMsg) resetMsg.style.display = 'none';

                try {
                    const res = await fetch('/api/reset_password', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ token: resetToken, password: newPassword })
                    });
                    const data = await res.json();

                    if (data.status === 'success') {
                        if (resetMsg) {
                            const text = (translations[currentLang] && translations[currentLang].passwordChanged) || "Contraseña cambiada";
                            resetMsg.textContent = text;
                            resetMsg.style.display = 'block';
                        }
                        setTimeout(() => {
                            // Clear URL
                            window.history.replaceState({}, document.title, "/");
                            // Go back to login
                            switchView('main');
                        }, 2000);
                    } else {
                        if (resetError) resetError.textContent = data.message || "Error";
                    }
                } catch (err) {
                    console.error(err);
                    if (resetError) resetError.textContent = "Error de conexión";
                }
            };
        }
    }
}

// FIX: Modal Closing Monkey Patch
// Ensure that removing 'active' class also clears inline display style
if (document.getElementById('auth-modal')) {
    const _authModal = document.getElementById('auth-modal');
    const originalRemove = _authModal.classList.remove.bind(_authModal.classList);

    _authModal.classList.remove = function (...args) {
        // If we represent the classList as an object/shim, this might be tricky, 
        // but since we are patching the instance method, it works for this element.
        originalRemove(...args);
        if (args.includes('active')) {
            _authModal.style.display = ''; // Clear inline style
        }
    };

    // Also patch Close Button to be sure
    const closeAuthBtn = document.getElementById('close-auth');
    if (closeAuthBtn) {
        const newClose = closeAuthBtn.cloneNode(true);
        closeAuthBtn.parentNode.replaceChild(newClose, closeAuthBtn);
        newClose.addEventListener('click', () => {
            _authModal.classList.remove('active');
            _authModal.style.display = '';
        });
    }
}


// Toggle Password Visibility
window.togglePasswordVisibility = function (inputId, iconSpan) {
    const input = document.getElementById(inputId);
    if (!input) return;

    const isPassword = input.type === 'password';
    input.type = isPassword ? 'text' : 'password';

    // Icons
    const eyeIcon = '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle></svg>';
    const eyeSlashIcon = '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"></path><line x1="1" y1="1" x2="23" y2="23"></line></svg>';

    if (isPassword) {
        // Now it's text (visible), so show icon to Hide (Eye Slash)
        iconSpan.innerHTML = eyeSlashIcon;
        input.classList.add('password-visible');
    } else {
        // Now it's password (hidden), so show icon to Show (Eye)
        iconSpan.innerHTML = eyeIcon;
        input.classList.remove('password-visible');
    }
};

// MAIN INITIALIZATION
// Replaces previous init wrappers
init = async function () {
    console.log("Starting App Initialization...");

    // 1. Fetch Data
    try {
        const response = await fetch('/api/foods');
        if (!response.ok) throw new Error('Error al cargar datos');
        foodDatabase = await response.json();

        // Initial Render
        filterAndRender();

        // Render Tabs
        renderTabs();
    } catch (error) {
        console.error("Error cargando alimentos:", error);
        if (typeof gridContainer !== 'undefined' && gridContainer) {
            gridContainer.innerHTML = '<p style="color: white; text-align: center; margin-top: 2rem;">Error al cargar los alimentos. Asegúrate de que el servidor esté corriendo.</p>';
        }
    }

    // 2. Setup Modules
    // Use try-catch for each to prevent one failure stopping others
    try { setupEventListeners(); } catch (e) { console.error("Setup Listeners failed", e); }
    try { setupCustomSelects(); } catch (e) { console.error("Setup Selects failed", e); }
    try { setupAuth(); } catch (e) { console.error("Setup Auth failed", e); }
    try { setupMedical(); } catch (e) { console.error("Setup Medical failed", e); }
    try { loadChatHistory(); } catch (e) { console.error("Load Chat failed", e); }

    // 3. Setup Fixed Password Reset
    try { setupPasswordResetFixed(); } catch (e) { console.error("Setup Reset failed", e); }

    // 4. Initial Language
    updateLanguage('es');

    console.log("App Initialization Complete.");
};

// Run
init();
